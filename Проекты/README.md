# Проектные задания

В этом разделе описаны проектные задания, выполнение которых может стать альтернативным способом получения зачёта. Формат отчёта по этим заданиям — это личный GitHub-репозиторий, в котором хранится весь необходимый код для того, чтобы воспроизвести результаты анализа. Также он должен содержать .pdf-файл с отчётом и подробным описанием результатов с классической для академических статей структурой (главное, чтобы были **Материалы и методы**, **Результаты** и **Выводы**).

## Задание по блоку «Bulk RNA-Seq»

Внимательно прочитайте статью [Takahashi et al., **Neuron**, 2022](https://github.com/serjisa/transcriptomics.msu/blob/main/Проекты/Takahashi%20et%20al.%2C%20Neuron%2C%202022.pdf). В отчёте кратко опишите основные находки авторов. В статье найдите идентификатор GEO, по которому можно найти образцы, которые авторы отсеквенировали для своей работы.

Прочитайте статью [Faulkner, **bioRxiv**, 2022](https://www.biorxiv.org/content/10.1101/2022.10.06.511227v1), в которой автор утверждает, что основные результаты статьи из журнала Neuron — это результат батч-эффекта в данных. Объясните, откуда, по мнению автора, берётся этот батч-эффект? Что автор статьи сделал для того, чтобы подтвердить свои догадки?

Попробуйте воспроизвести результаты из опубликованной на bioRxiv работы, но с использованием другого пайплайна, а именно с использованием kallisto. Для этого вам необходимо будет сделать, помимо обычного референса, также и интронный референс. Подумайте, как лучше его сделать и как лучше использовать результаты работы kallisto на нём. Можете ориентироваться на [некоторые подсказки](https://github.com/pachterlab/kallisto/issues/219) или же воспользоваться инструментом для scRNA-Seq анализа <code>[kallisto-bustools](https://github.com/pachterlab/kb_python)</code>. **Важно**: если вы будете использовать <code>kallisto-bustools</code>, то обязательно запускайте его в режиме подсчёта экспрессий эксперимента Smart-seq2! Также обратите внимание на то, что изучаемые в статье генетические элементы часто располагаются в интронах. Как вы будете (и будете ли?) использовать это знание при подсчёте экспрессий при помощи вашего пайплайна?

Воспроизводятся ли результаты? Что вы можете сказать насчёт эффективности использования kallisto для оценки количества интронных прочтений? При анализе дифференциальной экспрессии используйте процент интронной экспрессии для образца как один из факторов. Как добавление этого фактора меняет результаты?

В отчёте по заданию обязательно должны присутствовать следующие элементы:
1. .pdf-файл с письменным описанием методов и результатов,
2. Nextflow-пайплайн, который на вход принимает SRA идентификатор, а на выход даёт матрицы с обсчитанными интронными и экзонными экспрессиями,
3. Jupyter-notebook со статистическим анализом и графиками,
4. промежуточные матрицы с экспрессиями, которые вы получили в ходе анализа.

Весь код должен быть 100% воспроизводимым.

## Задание по блоку «Single cell RNA-Seq»

Внимательно прочитайте статью [Kang et al., **Nature Communication**, 2021](https://www.nature.com/articles/s41467-021-25957-x), в которой описывается метод для Label transfer при помощи алгоритма, основанном на Harmony. Несмотря на то, что Harmony сейчас стойко ассоциируется с Python-based методами коррекции батч-эффекта, оригинальный алгоритм был имплементирован в R, и только потом уже он был написан для Python (в виде `harmonypy`). Вашей задачей в ходе данного проекта будет создать pure Python имплементацию алгоритма Symphony (т.е. **без использования `rpy2`**) и показать, что эта имплементация эквивалентна версии для R.

Внимательно изучите репозиторий с Symphony и поймите основные шаги, необходимые для Label transfer при помощи Symphony. Какие данные необходимо запоминать для референса, чтобы в итоге воспроизвести весь функционал оригинального пакета? Каким образом вы собираетесь выполнить проекцию UMAP? Похожая задача (проекция UMAP) реализована в функции `scanpy.tl.ingest()`, можете воспользоваться кодом из этой функции. В качестве отчёта по заданию необходимо предоставить два репозитория:

1. репозиторий с имплементацией Symhony (готовый Python пакет, [можете почитать, как делать такие пакеты](https://www.tutorialsteacher.com/python/python-package)) с кратким описанием основных функций и использования пакета,
2. репозиторий, в котором будут храниться Jupyter-блокноты с детальным сравнением работы Symphony и вашей имплементацией.

Весь код должен быть 100% воспроизводимым.
